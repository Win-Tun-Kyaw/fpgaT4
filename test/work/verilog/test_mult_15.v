/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module test_mult_15 (
    input clk,
    input rst,
    input button,
    output reg [15:0] out,
    output reg done,
    output reg start,
    output reg error,
    output reg [7:0] checkoff
  );
  
  
  
  wire [16-1:0] M_mult_p;
  reg [16-1:0] M_mult_x;
  reg [16-1:0] M_mult_y;
  sixteen_bit_multiplier_19 mult (
    .x(M_mult_x),
    .y(M_mult_y),
    .p(M_mult_p)
  );
  
  wire [1-1:0] M_edge_detector_out;
  reg [1-1:0] M_edge_detector_in;
  edge_detector_9 edge_detector (
    .clk(clk),
    .in(M_edge_detector_in),
    .out(M_edge_detector_out)
  );
  localparam START_testMult = 3'd0;
  localparam MULT0_testMult = 3'd1;
  localparam ERR_testMult = 3'd2;
  localparam DONE_testMult = 3'd3;
  localparam ERRCASE_testMult = 3'd4;
  localparam MULTPP_testMult = 3'd5;
  localparam MULTPN_testMult = 3'd6;
  localparam MULTNN_testMult = 3'd7;
  
  reg [2:0] M_testMult_d, M_testMult_q = START_testMult;
  reg [15:0] M_product_d, M_product_q = 1'h0;
  reg [7:0] M_checkoffflag_d, M_checkoffflag_q = 1'h0;
  reg M_doneflag_d, M_doneflag_q = 1'h0;
  reg M_errorflag_d, M_errorflag_q = 1'h0;
  reg M_startflag_d, M_startflag_q = 1'h0;
  
  localparam ZERO = 16'h0000;
  
  localparam POS1 = 16'h0005;
  
  localparam POS2 = 16'h0005;
  
  localparam MULTPP = 16'h0019;
  
  localparam NEG1 = 16'hffff;
  
  localparam NEG2 = 16'hfff0;
  
  localparam MULTNN = 16'h0010;
  
  localparam MULTPN = 16'hfffb;
  
  localparam ERR1 = 16'h0006;
  
  localparam ERR2 = 16'h0004;
  
  localparam ERR12 = 16'h0018;
  
  always @* begin
    M_testMult_d = M_testMult_q;
    M_product_d = M_product_q;
    M_startflag_d = M_startflag_q;
    M_doneflag_d = M_doneflag_q;
    M_errorflag_d = M_errorflag_q;
    M_checkoffflag_d = M_checkoffflag_q;
    
    out = M_product_q;
    M_mult_x = 1'h0;
    M_mult_y = 1'h0;
    checkoff = M_checkoffflag_q;
    done = M_doneflag_q;
    error = M_errorflag_q;
    start = M_startflag_q;
    M_edge_detector_in = button;
    
    case (M_testMult_q)
      START_testMult: begin
        M_startflag_d = 1'h1;
        M_product_d = 16'h8888;
        out = M_product_q;
        M_checkoffflag_d = 16'h0000;
        if (M_edge_detector_out == 1'h1) begin
          M_testMult_d = MULT0_testMult;
        end
      end
      MULT0_testMult: begin
        M_mult_x = 16'h0005;
        M_mult_y = 16'h0000;
        M_product_d = M_mult_p;
        M_checkoffflag_d[7+0-:1] = 1'h1;
        if (M_mult_p == 16'h0000) begin
          out = M_product_q;
          if (M_edge_detector_out == 1'h1) begin
            M_testMult_d = MULTPP_testMult;
          end
        end else begin
          M_testMult_d = ERR_testMult;
        end
      end
      MULTPP_testMult: begin
        M_mult_x = 16'h0005;
        M_mult_y = 16'h0005;
        M_product_d = M_mult_p;
        M_checkoffflag_d[6+0-:1] = 1'h1;
        if (M_mult_p == 16'h0019) begin
          out = M_product_q;
          if (M_edge_detector_out == 1'h1) begin
            M_testMult_d = MULTPN_testMult;
          end
        end else begin
          M_testMult_d = ERR_testMult;
        end
      end
      MULTPN_testMult: begin
        M_mult_x = 16'h0005;
        M_mult_y = 16'hffff;
        M_product_d = M_mult_p;
        M_checkoffflag_d[5+0-:1] = 1'h1;
        if (M_mult_p == 16'hfffb) begin
          out = M_product_q;
          if (M_edge_detector_out == 1'h1) begin
            M_testMult_d = MULTNN_testMult;
          end
        end else begin
          M_testMult_d = ERR_testMult;
        end
      end
      MULTNN_testMult: begin
        M_mult_x = 16'hffff;
        M_mult_y = 16'hfff0;
        M_product_d = M_mult_p;
        M_checkoffflag_d[4+0-:1] = 1'h1;
        if (M_mult_p == 16'h0010) begin
          out = M_product_q;
          if (M_edge_detector_out == 1'h1) begin
            M_testMult_d = ERRCASE_testMult;
          end
        end else begin
          M_testMult_d = ERR_testMult;
        end
      end
      DONE_testMult: begin
        M_doneflag_d = 1'h1;
        M_product_d = 16'hc001;
        out = M_product_q;
        M_checkoffflag_d = 8'hff;
        if (M_edge_detector_out == 1'h1) begin
          M_testMult_d = START_testMult;
        end
      end
      ERR_testMult: begin
        M_errorflag_d = 1'h1;
        M_product_d = 16'hdead;
        out = M_product_q;
        M_checkoffflag_d[2+0-:1] = 1'h1;
        if (M_edge_detector_out == 1'h1) begin
          M_testMult_d = DONE_testMult;
        end
      end
      ERRCASE_testMult: begin
        M_mult_x = 16'h0006;
        M_mult_y = 16'h0004;
        M_product_d = M_mult_p;
        M_checkoffflag_d[3+0-:1] = 1'h1;
        if (M_mult_p == 16'h0018) begin
          out = M_product_q;
          if (M_edge_detector_out == 1'h1) begin
            M_testMult_d = ERR_testMult;
          end
        end else begin
          out = M_product_q;
          M_testMult_d = DONE_testMult;
        end
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_product_q <= 1'h0;
      M_checkoffflag_q <= 1'h0;
      M_doneflag_q <= 1'h0;
      M_errorflag_q <= 1'h0;
      M_startflag_q <= 1'h0;
      M_testMult_q <= 1'h0;
    end else begin
      M_product_q <= M_product_d;
      M_checkoffflag_q <= M_checkoffflag_d;
      M_doneflag_q <= M_doneflag_d;
      M_errorflag_q <= M_errorflag_d;
      M_startflag_q <= M_startflag_d;
      M_testMult_q <= M_testMult_d;
    end
  end
  
endmodule
