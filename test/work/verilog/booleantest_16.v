/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module booleantest_16 (
    input clk,
    input rst,
    input button,
    output reg [15:0] s,
    output reg [5:0] checkoff,
    output reg [0:0] flag
  );
  
  
  
  wire [16-1:0] M_boolean_s;
  reg [16-1:0] M_boolean_a;
  reg [16-1:0] M_boolean_b;
  reg [6-1:0] M_boolean_op;
  boolean_20 boolean (
    .a(M_boolean_a),
    .b(M_boolean_b),
    .op(M_boolean_op),
    .s(M_boolean_s)
  );
  
  wire [1-1:0] M_edge_detector_out;
  reg [1-1:0] M_edge_detector_in;
  edge_detector_9 edge_detector (
    .clk(clk),
    .in(M_edge_detector_in),
    .out(M_edge_detector_out)
  );
  reg [5:0] M_checkoff_reg_d, M_checkoff_reg_q = 1'h0;
  reg [0:0] M_flag_reg_d, M_flag_reg_q = 1'h0;
  reg [15:0] M_s_reg_d, M_s_reg_q = 1'h0;
  localparam START_state = 3'd0;
  localparam AND_state = 3'd1;
  localparam OR_state = 3'd2;
  localparam XOR_state = 3'd3;
  localparam A_state = 3'd4;
  localparam PASS_state = 3'd5;
  localparam ERRCASE_state = 3'd6;
  localparam ERR_state = 3'd7;
  
  reg [2:0] M_state_d, M_state_q = START_state;
  
  localparam A1 = 16'h6857;
  
  localparam B1 = 16'hac08;
  
  always @* begin
    M_state_d = M_state_q;
    M_flag_reg_d = M_flag_reg_q;
    M_s_reg_d = M_s_reg_q;
    M_checkoff_reg_d = M_checkoff_reg_q;
    
    s = M_s_reg_q;
    M_boolean_a = 1'h0;
    M_boolean_b = 1'h0;
    M_boolean_op = 1'h0;
    checkoff = M_checkoff_reg_q;
    flag = M_flag_reg_q;
    s = M_s_reg_q;
    M_edge_detector_in = button;
    
    case (M_state_q)
      START_state: begin
        M_flag_reg_d = 1'h0;
        M_s_reg_d = 16'hb001;
        M_checkoff_reg_d = 1'h0;
        if (M_edge_detector_out == 1'h1) begin
          M_state_d = AND_state;
        end
      end
      AND_state: begin
        M_boolean_a = 16'h6857;
        M_boolean_b = 16'hac08;
        M_boolean_op = 4'h8;
        M_s_reg_d = M_boolean_s;
        M_checkoff_reg_d[5+0-:1] = 1'h1;
        M_flag_reg_d = (M_s_reg_q != 16'h2800);
        if (M_boolean_s == 16'h2800) begin
          if (M_edge_detector_out == 1'h1) begin
            M_state_d = OR_state;
          end
        end else begin
          M_state_d = ERR_state;
        end
      end
      OR_state: begin
        M_boolean_a = 16'h6857;
        M_boolean_b = 16'hac08;
        M_boolean_op = 4'he;
        M_s_reg_d = M_boolean_s;
        M_checkoff_reg_d[4+0-:1] = 1'h1;
        M_flag_reg_d = (M_s_reg_q != 16'hec5f);
        if (M_boolean_s == 16'hec5f) begin
          if (M_edge_detector_out == 1'h1) begin
            M_state_d = XOR_state;
          end
        end else begin
          M_state_d = ERR_state;
        end
      end
      XOR_state: begin
        M_boolean_a = 16'h6857;
        M_boolean_b = 16'hac08;
        M_boolean_op = 3'h6;
        M_s_reg_d = M_boolean_s;
        M_checkoff_reg_d[3+0-:1] = 1'h1;
        M_flag_reg_d = (M_s_reg_q != 16'hc45f);
        if (M_boolean_s == 16'hc45f) begin
          if (M_edge_detector_out == 1'h1) begin
            M_state_d = A_state;
          end
        end else begin
          M_state_d = ERR_state;
        end
      end
      A_state: begin
        M_boolean_a = 16'h6857;
        M_boolean_b = 16'hac08;
        M_boolean_op = 4'ha;
        M_s_reg_d = M_boolean_s;
        M_checkoff_reg_d[2+0-:1] = 1'h1;
        M_flag_reg_d = (M_s_reg_q != 16'h6857);
        if (M_boolean_s == 16'h6857) begin
          if (M_edge_detector_out == 1'h1) begin
            M_state_d = ERRCASE_state;
          end
        end else begin
          M_state_d = ERR_state;
        end
      end
      ERRCASE_state: begin
        M_boolean_a = 16'h6857;
        M_boolean_b = 16'hac08;
        M_boolean_op = 4'ha;
        M_s_reg_d = 16'hdead;
        M_checkoff_reg_d[1+0-:1] = 1'h1;
        M_flag_reg_d = (M_s_reg_q != 16'h6857);
        if (M_boolean_s == 16'h6857) begin
          if (M_edge_detector_out == 1'h1) begin
            M_state_d = PASS_state;
          end
        end else begin
          M_state_d = ERR_state;
        end
      end
      PASS_state: begin
        M_flag_reg_d = 8'hff;
        M_checkoff_reg_d = 8'hff;
        M_s_reg_d = 16'hc001;
        M_flag_reg_d = 1'h0;
        if (M_edge_detector_out == 1'h1) begin
          M_state_d = START_state;
        end
      end
      ERR_state: begin
        if (M_edge_detector_out == 1'h1) begin
          M_state_d = PASS_state;
        end
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_state_q <= 1'h0;
    end else begin
      M_state_q <= M_state_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_flag_reg_q <= 1'h0;
    end else begin
      M_flag_reg_q <= M_flag_reg_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_s_reg_q <= 1'h0;
    end else begin
      M_s_reg_q <= M_s_reg_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_checkoff_reg_q <= 1'h0;
    end else begin
      M_checkoff_reg_q <= M_checkoff_reg_d;
    end
  end
  
endmodule
