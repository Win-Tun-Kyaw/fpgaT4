/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module sraTest_14 (
    input clk,
    input rst,
    input button,
    output reg [15:0] out,
    output reg [7:0] checkoff,
    output reg [0:0] flag,
    output reg [15:0] s
  );
  
  
  
  wire [16-1:0] M_shift_s;
  reg [16-1:0] M_shift_x;
  reg [16-1:0] M_shift_y;
  reg [6-1:0] M_shift_op;
  shifter16_17 shift (
    .x(M_shift_x),
    .y(M_shift_y),
    .op(M_shift_op),
    .s(M_shift_s)
  );
  
  wire [1-1:0] M_edge_detector_out;
  reg [1-1:0] M_edge_detector_in;
  edge_detector_9 edge_detector (
    .clk(clk),
    .in(M_edge_detector_in),
    .out(M_edge_detector_out)
  );
  reg [7:0] M_checkoff_reg_d, M_checkoff_reg_q = 1'h0;
  reg [0:0] M_flag_reg_d, M_flag_reg_q = 1'h0;
  reg [15:0] M_s_reg_d, M_s_reg_q = 1'h0;
  localparam START_testCase = 3'd0;
  localparam RSA1_testCase = 3'd1;
  localparam RSA2_testCase = 3'd2;
  localparam RSA4_testCase = 3'd3;
  localparam RSA8_testCase = 3'd4;
  localparam ERR00_testCase = 3'd5;
  localparam END_testCase = 3'd6;
  localparam ERROR_STATE_testCase = 3'd7;
  
  reg [2:0] M_testCase_d, M_testCase_q = START_testCase;
  
  localparam RSA1_X = 16'hf001;
  
  localparam RSA1_ALUFN = 6'h23;
  
  localparam RSA1_Y = 16'h0001;
  
  localparam RSA1_S = 16'hf800;
  
  localparam RSA2_X = 16'hf001;
  
  localparam RSA2_ALUFN = 6'h23;
  
  localparam RSA2_Y = 16'h0002;
  
  localparam RSA2_S = 16'hfc00;
  
  localparam RSA4_X = 16'hf001;
  
  localparam RSA4_ALUFN = 6'h23;
  
  localparam RSA4_Y = 16'h0004;
  
  localparam RSA4_S = 16'hff00;
  
  localparam RSA8_X = 16'hf001;
  
  localparam RSA8_ALUFN = 6'h23;
  
  localparam RSA8_Y = 16'h0008;
  
  localparam RSA8_S = 16'hfff0;
  
  localparam ERR00_X = 16'hf001;
  
  localparam ERR00_ALUFN = 6'h23;
  
  localparam ERR00_Y = 16'h0008;
  
  localparam ERR00_S = 16'h0000;
  
  always @* begin
    M_testCase_d = M_testCase_q;
    M_flag_reg_d = M_flag_reg_q;
    M_s_reg_d = M_s_reg_q;
    M_checkoff_reg_d = M_checkoff_reg_q;
    
    checkoff = M_checkoff_reg_q;
    flag = M_flag_reg_q;
    s = M_s_reg_q;
    out = M_s_reg_q;
    M_shift_x = 1'h0;
    M_shift_y = 1'h0;
    M_shift_op = 1'h0;
    M_edge_detector_in = button;
    
    case (M_testCase_q)
      START_testCase: begin
        M_flag_reg_d = 8'h00;
        M_s_reg_d = 16'h5f7a;
        M_checkoff_reg_d = 16'h0000;
        if (M_edge_detector_out == 1'h1) begin
          M_testCase_d = RSA1_testCase;
        end
      end
      RSA1_testCase: begin
        M_shift_x = 16'hf001;
        M_shift_y = 16'h0001;
        M_shift_op = 6'h23;
        M_checkoff_reg_d[7+0-:1] = 1'h1;
        M_flag_reg_d = (M_shift_s != 16'hf800);
        M_s_reg_d = M_shift_s;
        if (M_shift_s == 16'hf800) begin
          if (M_edge_detector_out == 1'h1) begin
            M_testCase_d = RSA2_testCase;
          end
        end else begin
          M_testCase_d = ERROR_STATE_testCase;
        end
      end
      RSA2_testCase: begin
        M_shift_x = 16'hf001;
        M_shift_y = 16'h0002;
        M_shift_op = 6'h23;
        M_checkoff_reg_d[6+0-:1] = 1'h1;
        M_flag_reg_d = (M_shift_s != 16'hfc00);
        M_s_reg_d = M_shift_s;
        if (M_shift_s == 16'hfc00) begin
          if (M_edge_detector_out == 1'h1) begin
            M_testCase_d = RSA4_testCase;
          end
        end else begin
          M_testCase_d = ERROR_STATE_testCase;
        end
      end
      RSA4_testCase: begin
        M_shift_x = 16'hf001;
        M_shift_y = 16'h0004;
        M_shift_op = 6'h23;
        M_checkoff_reg_d[5+0-:1] = 1'h1;
        M_flag_reg_d = (M_shift_s != 16'hff00);
        M_s_reg_d = M_shift_s;
        if (M_shift_s == 16'hff00) begin
          if (M_edge_detector_out == 1'h1) begin
            M_testCase_d = RSA8_testCase;
          end
        end else begin
          M_testCase_d = ERROR_STATE_testCase;
        end
      end
      RSA8_testCase: begin
        M_shift_x = 16'hf001;
        M_shift_y = 16'h0008;
        M_shift_op = 6'h23;
        M_checkoff_reg_d[4+0-:1] = 1'h1;
        M_flag_reg_d = (M_shift_s != 16'hfff0);
        M_s_reg_d = M_shift_s;
        if (M_shift_s == 16'hfff0) begin
          if (M_edge_detector_out == 1'h1) begin
            M_testCase_d = ERR00_testCase;
          end
        end else begin
          M_testCase_d = ERROR_STATE_testCase;
        end
      end
      ERR00_testCase: begin
        M_shift_x = 16'hf001;
        M_shift_y = 16'h0008;
        M_shift_op = 6'h23;
        M_checkoff_reg_d[3+0-:1] = 1'h1;
        M_flag_reg_d = (M_shift_s != 16'h0000);
        M_s_reg_d = 16'hdead;
        if (M_shift_s == 16'h0000) begin
          if (M_edge_detector_out == 1'h1) begin
            M_testCase_d = END_testCase;
          end
        end else begin
          M_testCase_d = ERROR_STATE_testCase;
        end
      end
      ERROR_STATE_testCase: begin
        if (M_edge_detector_out == 1'h1) begin
          M_testCase_d = END_testCase;
        end
      end
      END_testCase: begin
        M_flag_reg_d = 1'h1;
        M_checkoff_reg_d = 8'hff;
        M_s_reg_d = 16'hc001;
        s = M_s_reg_q;
        flag = M_flag_reg_q;
        checkoff = M_checkoff_reg_q;
        if (M_edge_detector_out == 1'h1) begin
          M_testCase_d = START_testCase;
        end
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_s_reg_q <= 1'h0;
    end else begin
      M_s_reg_q <= M_s_reg_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_testCase_q <= 1'h0;
    end else begin
      M_testCase_q <= M_testCase_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_checkoff_reg_q <= 1'h0;
    end else begin
      M_checkoff_reg_q <= M_checkoff_reg_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_flag_reg_q <= 1'h0;
    end else begin
      M_flag_reg_q <= M_flag_reg_d;
    end
  end
  
endmodule
