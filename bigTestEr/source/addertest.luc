module addertest (
    input clk,  // clock
    input rst,  // reset
    input button,
    input endbutton,
    output z,
    output v,
    output n,
    output checkoff[8], // is current correct????
    output flag[4], // output the flags for this error
    output s[16] // output of sum value, 
   ) {
      // declare modules and constants 
      sixteen_bit_full_adder fa;
    .clk(clk) {
      edge_detector edge_detector(#RISE(1), #FALL(0));
      edge_detector end_detector(#RISE(1),#FALL(0));
      .rst(rst) {
        // register to show which test case we are on. 
        // lit nth bit starting from the left, means we are currently at nth case
        // output to the right bakn of leds
        dff checkoff_reg[8](#INIT(0), .clk(clk), .rst(rst));
        // error state left bit to right bit
        // z v n s
        // output to the middle bank of leds,
        dff flag_reg[4](#INIT(0), .clk(clk), .rst(rst));
        // error s 
        dff s_reg[16](#INIT(0), .clk(clk), .rst(rst));
        // end reg for indicating if we are at end state
        // we move to the next state by pressing the centre io button
        // in each state we do the calculation and then print the result to the segment display
        // when catching a error, i.e the err state, we go immediately to error state
        // in error state we can return to start state by pressing centre io button
        // in error state, print the error state z v n s values that are wrong in the the middle led bank
        // pressing the left button jumps to end state so we can demonstrate how 
        fsm testCase(#INIT(START), .clk(clk), .rst(rst)) = {START,PPP,PPN,PNN,PPV,PNV,PP0,ERR,END,ERROR_STATE};
      }
    }
    //P+P no flag PPP
    //P-P N flag PPN
    //P+N no flag PNN
    //P+P V flag PPV
    //N-P V flag PNV
    //P-P Z flag PP0
    //ERROR all s and flag values are wrong ERR
    // from left to the right of second bank of ioled
    // z v n s
    // constants test conditions
    // PPP
    const PPP_X = 16h5e94;
    const PPP_ALUFN = b000000;  
    const PPP_Y = 16h132f;
    const PPP_S = 16h71c3;
    const PPP_Z = 0;      
    const PPP_V = 0;      
    const PPP_N = 0;      


    // PPN
    const PPN_X = 16h1a4d;
    const PPN_ALUFN = b000001;  
    const PPN_Y = 16h34ff;
    const PPN_S = 16he54e;
    const PPN_Z = 0;      
    const PPN_V = 0;      
    const PPN_N = 1;      


    // PNN
    const PNN_X = 16h2ff3;
    const PNN_ALUFN = b000000;  
    const PNN_Y = 16h9f22;
    const PNN_S = 16hcf15;
    const PNN_Z = 0;      
    const PNN_V = 0;      
    const PNN_N = 1;      


    // PPV
    const PPV_X = 16h0001;
    const PPV_ALUFN = b00000;  
    const PPV_Y = 16h7FFF;
    const PPV_S = 16h8000;
    const PPV_Z = 0;      
    const PPV_V = 1;      
    const PPV_N = 1;      

    // PNV
    const PNV_X = 16h8000;
    const PNV_ALUFN = b000001;
    const PNV_Y = 16h0001;
    const PNV_S = 16h7fff;
    const PNV_Z = 0;
    const PNV_V = 1;
    const PNV_N = 0;


    // PP0
    const PP0_X = 16h0001;
    const PP0_ALUFN = b000001;
    const PP0_Y = 16h0001;
    const PP0_S = 16h0000;
    const PP0_Z = 1;
    const PP0_V = 0;
    const PP0_N = 0;


    // ERR
    const ERR_X = 16h0001;
    const ERR_ALUFN = b000000;
    const ERR_Y = 16h0001;
    const ERR_S = 16hFFFF;
    const ERR_Z = 1;
    const ERR_V = 1;
    const ERR_N = 1;
   
    

 always {
    // q is out and d is input for dff 
    // default outputs
    v = fa.v;
    n = fa.n;
    z = fa.z;
    checkoff = checkoff_reg.q;
    flag = flag_reg.q;
    s = s_reg.q;

    // default inputs
    fa.x = 0;
    fa.y = 0; 
    fa.op = 0;

    edge_detector.in = button;
    end_detector.in = endbutton;


    //declare fsm
    case (testCase.q) {
        testCase.START:
        // we reset all the values to zero, in case we come to start state 
        // from a previous state with flag, checkoff and s values
 //       flag = 8h00;
//        checkoff = 8h00;
//        s = 16hADDE;
        //
        flag_reg.d = 8h00;
        s_reg.d = 16hADDE;
        checkoff_reg.d = 16h0000;
        if (edge_detector.out == 1) {
          testCase.d = testCase.PPP;
        }
        // PPP
        testCase.PPP:
        fa.x = PPP_X;
        fa.y = PPP_Y;
        fa.op = PPP_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[7] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PPP_Z);
        flag_reg.d[2] = (fa.v != PPP_V);
        flag_reg.d[1] = (fa.n != PPP_N);
        flag_reg.d[0] = (fa.s != PPP_S);
        s_reg.d = fa.s;
        if (fa.s == PPP_S & fa.z == PPP_Z & fa.n == PPP_N & fa.v == PPP_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.PPN;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // PPN
        testCase.PPN:
        fa.x = PPN_X;
        fa.y = PPN_Y;
        fa.op = PPN_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[6] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PPN_Z);
        flag_reg.d[2] = (fa.v != PPN_V);
        flag_reg.d[1] = (fa.n != PPN_N);
        flag_reg.d[0] = (fa.s != PPN_S);
        s_reg.d = fa.s;
        if (fa.s == PPN_S & fa.z == PPN_Z & fa.n == PPN_N & fa.v == PPN_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.PNN;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // PNN
        testCase.PNN:
        fa.x = PNN_X;
        fa.y = PNN_Y;
        fa.op = PNN_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[5] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PNN_Z);
        flag_reg.d[2] = (fa.v != PNN_V);
        flag_reg.d[1] = (fa.n != PNN_N);
        flag_reg.d[0] = (fa.s != PNN_S);
        s_reg.d = fa.s;
        if (fa.s == PNN_S & fa.z == PNN_Z & fa.n == PNN_N & fa.v == PNN_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.PPV;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // PPV
        testCase.PPV:
        fa.x = PPV_X;
        fa.y = PPV_Y;
        fa.op = PPV_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[4] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PPV_Z);
        flag_reg.d[2] = (fa.v != PPV_V);
        flag_reg.d[1] = (fa.n != PPV_N);
        flag_reg.d[0] = (fa.s != PPV_S);
        s_reg.d = fa.s;
        if (fa.s == PPV_S & fa.z == PPV_Z & fa.n == PPV_N & fa.v == PPV_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.PNV;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // PNV
        testCase.PNV:
        fa.x = PNV_X;
        fa.y = PNV_Y;
        fa.op = PNV_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[3] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PNV_Z);
        flag_reg.d[2] = (fa.v != PNV_V);
        flag_reg.d[1] = (fa.n != PNV_N);
        flag_reg.d[0] = (fa.s != PNV_S);
        s_reg.d = fa.s;
        if (fa.s == PNV_S & fa.z == PNV_Z & fa.n == PNV_N & fa.v == PNV_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.PP0;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // PP0
        testCase.PP0:
        fa.x = PP0_X;
        fa.y = PP0_Y;
        fa.op = PP0_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[2] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != PP0_Z);
        flag_reg.d[2] = (fa.v != PP0_V);
        flag_reg.d[1] = (fa.n != PP0_N);
        flag_reg.d[0] = (fa.s != PP0_S);
        s_reg.d = fa.s;
        if (fa.s == PP0_S & fa.z == PP0_Z & fa.n == PP0_N & fa.v == PP0_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.ERR;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }


        // ERR
        testCase.ERR:
        fa.x = ERR_X;
        fa.y = ERR_Y;
        fa.op = ERR_ALUFN;
        //turn on io_led to indicate which case we are on
        checkoff_reg.d[1] = 1;
        //wait for the timer
        // check values
        flag_reg.d[3] = (fa.z != ERR_Z);
        flag_reg.d[2] = (fa.v != ERR_V);
        flag_reg.d[1] = (fa.n != ERR_N);
        flag_reg.d[0] = (fa.s != ERR_S);
        // show that we are at the value of err testcase 
        s_reg.d = 16hdead;
        if (fa.s == ERR_S & fa.z == ERR_Z & fa.n == ERR_N & fa.v == ERR_V){
            if (edge_detector.out == 1) {
                testCase.d = testCase.END;
            }
            } else {
                testCase.d = testCase.ERROR_STATE;
        }
      testCase.ERROR_STATE:
      // we remain in error state until we press button
      if (edge_detector.out ==1){
        testCase.d = testCase.START;
      } else if (end_detector.out ==1){
        // if we press the end button we go to the end state 
        testCase.d = testCase.END;
        }
      testCase.END:
      // turn on all the lights used 
      // turn the registers we use to all equal 1s bitwise
      flag_reg.d = 8h00;
      checkoff_reg.d = 8hff;
      // write cool on segment leds
      s_reg.d =16hc001;
      // output them registers
      s = s_reg.q;
      flag = flag_reg.q;
      checkoff = checkoff_reg.q;
      //remain in this state until we press the button
      if (edge_detector.out ==1){
        testCase.d = testCase.START;
      }    
    }

    
  }
}
